<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LIBLCG: LCG说明文档</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LIBLCG
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">C++ Library of Linear Conjugate Gradient Methods</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">LCG说明文档 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>张壹（zhangyiss@icloud.com）</p>
<p><em>浙江大学地球科学学院·地球物理研究所</em></p>
<h2>简介</h2>
<p>liblcg 是一个简单的 C++ 线性共轭梯度算法库，其中包含了一般形式的共轭梯度算法、预优共轭梯度算法、共轭梯度平方算法与双稳共轭梯度算法。可用于求解如下形式的线性方程组：</p>
<div class="fragment"><div class="line">Ax = B</div></div><!-- fragment --><p>其中，A 是一个 N 阶的方阵、x 为 N*1 的待求解的模型向量，B 为 N*1 的需拟合的目标向量。共轭梯度法广泛应用于无约束的线性最优化问题，拥有优良的收敛与计算效率。其中，共轭梯度法与预优共轭梯度法可用于求解A为对称形式的线性方程组，而共轭梯度平方法与双稳共轭梯度法可用于求解A为非对称形式的线性方程组。</p>
<h2>安装</h2>
<p>算法库默认使用 Cmake 编译工具进行编译，可在不同平台生成相应的可执行或工程文件。请用户自行下载安装 Cmake 软件后按如下方法进行编译。此方法适用于 MacOS 或 Linux 系统 （默认的编译器为 GCC-9，用户可在 CMakeLists.txt 中自行修改编译器与安装地址），Windows 用户请使用 VS studio 等编译工具新建项目并拷贝 src/lib 文件夹下所有文件至新项目并编译动态库。</p>
<div class="fragment"><div class="line">./routine.sh configure</div><div class="line">./routine.sh build</div></div><!-- fragment --><p>算法库目前有两个可用的编译选项，分别为 LCG_FABS 和 LCG_OPENMP，默认值均为 ON。其中 LCG_FABS 表示是否使用算法库自带的绝对值计算方法。若此值为 OFF 则会使用标准的（cmath）绝对值计算方法。 LCG_OPENMP 为是否使用 OpenMP 对算法进行加速。若此值为 OFF 则表示不使用openMP。用户可以使用以下方式进行条件编译：</p>
<div class="fragment"><div class="line">cmake .. -DLCG_FABS=OFF -DLCG_OPENMP=ON</div></div><!-- fragment --><p>用户也可以将算法库文件直接拷贝至自己的工程目录中编译使用。此时你需要拷贝的文件包含 src/lib 文件夹下的所有文件。</p>
<h2>数据类型</h2>
<ol type="1">
<li>浮点类型 <code>lcg_float</code> 。目前只是简单的 <code>double</code> 类型的别名；</li>
<li>枚举类型 <code>lcg_solver_enum</code> 包含了可用的共轭梯度类型。有 <code>LCG_CG</code>，<code>LCG_PCG</code>，<code>LCG_CGS</code>，<code>LCG_BICGSTAB</code>，<code>LCG_BICGSTAB2</code>共5个。分别表示共轭梯度、预优共轭梯度、共轭梯度平方算法与两种双稳共轭梯度算法；</li>
<li>结构体 <code><a class="el" href="structlcg__para.html" title="Parameter type for adjusting the algorithm">lcg_para</a></code> 为共轭梯度参数类型。包含 <code>max_iterations</code>，<code>epsilon</code>，<code>abs_diff</code>，<code>restart_epsilon</code> 四个变量，包含最大迭代次数、终止精度等条件变量。具体含义请见头文件内的注释。</li>
</ol>
<h2>头文件与函数接口</h2>
<p>使用库函数需在源文件中包含头文件<code><a class="el" href="lcg_8h.html">lcg.h</a></code>，可用的函数接口包括</p>
<ol type="1">
<li><code>lcg_float* <a class="el" href="lcg_8h.html#ad4d1ad1663815eb1214f7683acfd1cbe" title="Locate memory for lcg_float pointer type">lcg_malloc(const int n)</a></code> 开辟数组空间；</li>
<li><code>void <a class="el" href="lcg_8h.html#a51d9b69c6afbba37a48470b4e1db4739" title="Destroy memory used by lcg_float pointer type">lcg_free(lcg_float* x)</a></code> 释放数组空间；</li>
<li><code><a class="el" href="structlcg__para.html" title="Parameter type for adjusting the algorithm">lcg_para</a> <a class="el" href="lcg_8h.html#ae709a311e61bd35843a9f4333c38ab18" title="Return a lcg_para type with default values.">lcg_default_parameters()</a></code> 返回一组默认的共轭梯度参数；</li>
<li><code>const char* <a class="el" href="lcg_8h.html#a7d76a821bc6ddd804abaf1974e5d7583" title="return a string explanation for a solver&#39;s return values">lcg_error_str(int er_index)</a></code> 按照 <code><a class="el" href="lcg_8h.html#a6291c46aa8e2fa943bbe2afdd826e594" title="A combined conjugate gradient solver function">lcg_solver()</a></code> 函数的返回值显示可能的错误信息。</li>
</ol>
<h3>回调函数</h3>
<h4>自定义Ax计算函数</h4>
<p>通常我们在使用共轭梯度法求解线性方程组Ax=B时A的维度可能会很大，直接储存A将消耗大量的内存空间，因此一般并不直接计算并储存A而是在需要的时候计算Ax的乘积。因此用户在使用liblcg时需要定义Ax的计算函数。Ax计算函数的形式必须满足算法库定义的一般形式：</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">typedef void (*lcg_axfunc_ptr)(void* instance, const lcg_float* x, lcg_float* prod_Ax, const int n_size);</div></div><!-- fragment --><p>函数需定义4个参数，分别为：</p>
<ol type="1">
<li><code>void *instance</code> 传入的实例对象（无需使用）；</li>
<li><code>const lcg_float *x</code> Ax计算中的x数组的指针；</li>
<li><code>lcg_float *prod_Ax</code> Ax的乘积；</li>
<li><code>const int n_size</code> 矩阵的大小。</li>
</ol>
<h4>自定义进程监控函数</h4>
<p>用户可用下面的模版创建函数来显示共轭梯度迭代中的参数，并可以在适当的情况下停止迭代的进程。具体地，当监控函数的返回值非0时迭代进程便会终止。</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">typedef int (*lcg_progress_ptr)(void* instance, const lcg_float* m, const lcg_float converge, const lcg_para* param, const int n_size, const int k);</div></div><!-- fragment --><p>函数需定义6个参数（你不需要全部使用它们），分别为：</p><ol type="1">
<li><code>void* instance</code> 传入的实例对象（无需使用）；</li>
<li><code>const lcg_float* m</code> 当前迭代的模型参数数组；</li>
<li><code>const lcg_float converge</code> 当前迭代的目标值；</li>
<li><code>const lcg_para* param</code> 当前迭代过程使用的参数；</li>
<li><code>const int n_size</code> 模型数组的大小；</li>
<li><code>const int k</code> 当前迭代的次数。</li>
</ol>
<h2>求解函数</h2>
<p>用户在定义 Ax 计算函数与监控函数后即可调用求解函数 <a class="el" href="lcg_8h.html#a6291c46aa8e2fa943bbe2afdd826e594" title="A combined conjugate gradient solver function">lcg_solver()</a> 对线性方程组进行求解，同时提供初始解x与共轭梯度的B项（即拟合的对象）。如果使用预优方法还需要提供预优矩阵P项。目前可用的求解方法如下：</p>
<ol type="1">
<li>LCG_CG：共轭梯度算法；</li>
<li>LCG_PCG：预优共轭梯度算法；</li>
<li>LCG_CGS：共轭梯度平方算法；</li>
<li>LCG_BICGSTAB：双稳共轭梯度算法；</li>
<li>LCG_BICGSTAB2: 双稳共轭梯度算法（带重启功能）。</li>
</ol>
<p>求解函数的参数形式如下：</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">int lcg_solver(lcg_axfunc_ptr Afp, lcg_progress_ptr Pfp, lcg_float* m, const lcg_float* B, const int n_size, const lcg_para* param, void* instance, int solver_id const lcg_float* P);</div></div><!-- fragment --><p>函数接受9个参数，分别为：</p><ol type="1">
<li><code>lcg_axfunc_ptr Afp</code> 计算 Ax 的回调函数；</li>
<li><code>lcg_progress_ptr Pfp</code> 监控迭代过程的回调函数（非必须，无需监控时使用 NULL 参数即可）；</li>
<li><code>lcg_float* m</code> 模型参数数组，解得线性方程组的解也为这个数组；</li>
<li><code>const lcg_float* B</code> Ax = B 中的 B 项；</li>
<li><code>const int n_size</code> 模型参数数组的大小；</li>
<li><code>const lcg_para* param</code> 此次迭代使用的参数，此参数为 NULL 即使用默认参数；</li>
<li><code>void* instance</code> 传入的实例对象, 此函数在类中使用即为类的 this 指针, 在普通函数中使用时即为 NULL；</li>
<li><code>int solver_id</code> 求解函数使用的求解方法，即上文中 LCG_CG 至 LCG_BICGSTAB2 五种方法，默认的求解方法为 LCG_CGS；</li>
<li><code>const lcg_float* P</code> 预优矩阵，一般是一个N阶的对角阵，这里直接用一个一维数组表示。此参数只在求解方法为 LCG_PCG 时是必须的，其他情况下是一个默认值为 NULL 的参数。</li>
</ol>
<h2>示例</h2>
<p>以下为一个简单的例子。我们使用 <a class="el" href="lcg_8h.html#a6291c46aa8e2fa943bbe2afdd826e594" title="A combined conjugate gradient solver function">lcg_solver()</a> 求解一个3*3的对称形式的线性方程组。其中 Ax 计算函数与监控函数均为类的成员函数。</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">#include &quot;lcg.h&quot;   </div><div class="line">#include &quot;iostream&quot;   </div><div class="line"></div><div class="line">using std::cout;</div><div class="line">using std::clog;</div><div class="line">using std::endl;</div><div class="line"></div><div class="line">class TESTFUNC</div><div class="line">{</div><div class="line">public:</div><div class="line">  TESTFUNC();</div><div class="line">  ~TESTFUNC();</div><div class="line">  void Routine();</div><div class="line">  /**</div><div class="line">   * 因为类的成员函数指针不能直接被调用，所以我们在这里定义一个静态的中转函数来辅助Ax函数的调用</div><div class="line">   * 这里我们利用reinterpret_cast将_Ax的指针转换到Ax上，需要注意的是成员函数的指针只能通过</div><div class="line">   * 实例对象进行调用，因此需要void* instance变量。</div><div class="line">  */</div><div class="line">  static void _Ax(void* instance, const lcg_float* a, lcg_float* b, const int num)</div><div class="line">  {</div><div class="line">    return reinterpret_cast&lt;TESTFUNC*&gt;(instance)-&gt;Ax(a, b, num);</div><div class="line">  }</div><div class="line">  void Ax(const lcg_float* a, lcg_float* b, const int num); //定义共轭梯度中Ax的算法</div><div class="line"></div><div class="line">  static int _Progress(void* instance, const lcg_float* m, const lcg_float converge, const lcg_para *param, const int n_size, const int k)</div><div class="line">  {</div><div class="line">    return reinterpret_cast&lt;TESTFUNC*&gt;(instance)-&gt;Progress(m, converge, param, n_size, k);</div><div class="line">  }</div><div class="line">  int Progress(const lcg_float* m, const lcg_float converge, const lcg_para *param, const int n_size, const int k);</div><div class="line">private:</div><div class="line">  lcg_float* m_;</div><div class="line">  lcg_float* b_;</div><div class="line">  lcg_float* p_;</div><div class="line">  lcg_float kernel_[3][3];</div><div class="line">};</div><div class="line"></div><div class="line">TESTFUNC::TESTFUNC()</div><div class="line">{</div><div class="line">  // 测试线性方程组</div><div class="line">  // 6.3*x1 + 3.9*x2 + 2.5*x3 = -2.37</div><div class="line">  // 3.9*x1 + 1.2*x2 + 3.1*x3 = 5.82</div><div class="line">  // 2.5*x1 + 3.1*x2 + 7.6*x3 = 5.21</div><div class="line">  // 目标解 x1=1.2 x2=-3.7 x3=1.8</div><div class="line">  // 注意根据共轭梯度法的要求 kernel是一个N阶对称阵</div><div class="line">  kernel_[0][0] = 6.3; kernel_[0][1] = 3.9; kernel_[0][2] = 2.5;</div><div class="line">  kernel_[1][0] = 3.9; kernel_[1][1] = 1.2; kernel_[1][2] = 3.1;</div><div class="line">  kernel_[2][0] = 2.5; kernel_[2][1] = 3.1; kernel_[2][2] = 7.6;</div><div class="line">  // 初始解</div><div class="line">  m_ = lcg_malloc(3); // 开辟数组空间</div><div class="line">  m_[0] = 0.0; m_[1] = 0.0; m_[2] = 0.0;</div><div class="line">  // 拟合目标值（含有一定的噪声）</div><div class="line">  b_ = lcg_malloc(3);</div><div class="line">  b_[0] = -2.3723; b_[1] = 5.8201; b_[2] = 5.2065;</div><div class="line">  // 测试预优矩阵 这里只是测试流程 预优矩阵值全为1 并没有什么作用</div><div class="line">  p_ = lcg_malloc(3);</div><div class="line">  p_[0] = p_[1] = p_[2] = 1.0;</div><div class="line">}</div><div class="line"></div><div class="line">TESTFUNC::~TESTFUNC()</div><div class="line">{</div><div class="line">  lcg_free(m_); // 销毁数组使用的空间</div><div class="line">  lcg_free(b_);</div><div class="line">  lcg_free(p_);</div><div class="line">}</div><div class="line"></div><div class="line">void TESTFUNC::Ax(const lcg_float* a, lcg_float* b, const int num)</div><div class="line">{</div><div class="line">  for (int i = 0; i &lt; num; i++)</div><div class="line">  {</div><div class="line">    b[i] = 0.0;</div><div class="line">    for (int j = 0; j &lt; num; j++)</div><div class="line">    {</div><div class="line">      b[i] += kernel_[i][j]*a[j];</div><div class="line">    }</div><div class="line">  }</div><div class="line">  return;</div><div class="line">}</div><div class="line"></div><div class="line">int TESTFUNC::Progress(const lcg_float* m, const lcg_float converge, const lcg_para *param, const int n_size, const int k)</div><div class="line">{</div><div class="line">  clog &lt;&lt; &quot;Iteration-times: &quot; &lt;&lt; k &lt;&lt; &quot;\tconvergence: &quot; &lt;&lt; converge &lt;&lt; endl;</div><div class="line">  if (converge &gt; param-&gt;epsilon) clog &lt;&lt; &quot;\033[1A\033[K&quot;;</div><div class="line">  return 0;</div><div class="line">}</div><div class="line"></div><div class="line">void TESTFUNC::Routine()</div><div class="line">{</div><div class="line">  lcg_para self_para = lcg_default_parameters(); // 得到一个值等于默认值的参数类型</div><div class="line">  self_para.max_iterations = 10;</div><div class="line">  self_para.abs_diff = true;</div><div class="line"></div><div class="line">  // 使用LCG_CG求解 </div><div class="line">  int ret = lcg_solver(_Ax, _Progress, m_, b_, 3, &amp;self_para, this, LCG_CG);</div><div class="line">  if (ret &lt; 0)</div><div class="line">    cout &lt;&lt; lcg_error_str(ret) &lt;&lt; endl;</div><div class="line">  // 输出解</div><div class="line">  for (int i = 0; i &lt; 3; i++)</div><div class="line">  {</div><div class="line">    cout &lt;&lt; m_[i] &lt;&lt; endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  // rest m_ and solve with LCG_PCG</div><div class="line">  m_[0] = 0.0; m_[1] = 0.0; m_[2] = 0.0;</div><div class="line">  // use lpcg to solve the linear system</div><div class="line">  ret = lcg_solver(_Ax, _Progress, m_, b_, 3, &amp;self_para, this, LCG_PCG, p_);</div><div class="line">  if (ret &lt; 0)</div><div class="line">    cout &lt;&lt; lcg_error_str(ret) &lt;&lt; endl;</div><div class="line">  // output solution</div><div class="line">  for (int i = 0; i &lt; 3; i++)</div><div class="line">  {</div><div class="line">    cout &lt;&lt; m_[i] &lt;&lt; endl;</div><div class="line">  }</div><div class="line">  return;</div><div class="line">}</div><div class="line"></div><div class="line">int main(int argc, char const *argv[])</div><div class="line">{</div><div class="line">  TESTFUNC test;</div><div class="line">  test.Routine();</div><div class="line">  return 0;</div><div class="line">}</div></div><!-- fragment --><p>第二个例子，我们使用 <a class="el" href="lcg_8h.html#a6291c46aa8e2fa943bbe2afdd826e594" title="A combined conjugate gradient solver function">lcg_solver()</a> 求解一个随机的100*80的线性方程组的最小二乘解。其中 Ax 计算函数与监控函数均为全局函数。</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">#include &quot;lcg.h&quot;   </div><div class="line">#include &quot;ctime&quot;   </div><div class="line">#include &quot;random&quot;   </div><div class="line">#include &quot;iostream&quot;  </div><div class="line"></div><div class="line">#define M 100</div><div class="line">#define N 80</div><div class="line"></div><div class="line">//返回范围内的随机浮点值 注意调取函数之前要调用srand(time(0));</div><div class="line">double random_double(double L,double T)</div><div class="line">{</div><div class="line">  return (T-L)*rand()*1.0/RAND_MAX + L;</div><div class="line">}</div><div class="line"></div><div class="line">//返回范围内的随机整数 注意调取函数之前要调用srand(time(0));</div><div class="line">int random_int(int small, int big)</div><div class="line">{</div><div class="line">  return (rand() % (big - small))+ small;</div><div class="line">}</div><div class="line"></div><div class="line">// 普通二维数组做核矩阵</div><div class="line">double **kernel;</div><div class="line">// 中间结果数组</div><div class="line">double *tmp_arr;</div><div class="line"></div><div class="line">// 计算核矩阵乘向量的乘积</div><div class="line">void CalAx(void* instance, const lcg_float* x, lcg_float* prod_Ax, const int n_s)</div><div class="line">{</div><div class="line">  for (int i = 0; i &lt; M; i++)</div><div class="line">  {</div><div class="line">    tmp_arr[i] = 0.0;</div><div class="line">    for (int j = 0; j &lt; n_s; j++)</div><div class="line">    {</div><div class="line">      tmp_arr[i] += kernel[i][j] * x[j];</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  for (int j = 0; j &lt; n_s; j++)</div><div class="line">  {</div><div class="line">    prod_Ax[j] = 0.0;</div><div class="line">    for (int i = 0; i &lt; M; i++)</div><div class="line">    {</div><div class="line">      prod_Ax[j] += kernel[i][j] * tmp_arr[i];</div><div class="line">    }</div><div class="line">  }</div><div class="line">  return;</div><div class="line">}</div><div class="line"></div><div class="line">//定义共轭梯度监控函数</div><div class="line">int Prog(void* instance, const lcg_float* m, const lcg_float converge, const lcg_para* param, const int n_s, const int k)</div><div class="line">{</div><div class="line">  std::clog &lt;&lt; &quot;Iteration-times: &quot; &lt;&lt; k &lt;&lt; &quot;\tconvergence: &quot; &lt;&lt; converge &lt;&lt; std::endl;</div><div class="line">  if (converge &gt; param-&gt;epsilon) std::clog &lt;&lt; &quot;\033[1A\033[K&quot;;</div><div class="line">  return 0;</div><div class="line">}</div><div class="line"></div><div class="line">int main(int argc, char const *argv[])</div><div class="line">{</div><div class="line">  kernel = new double *[M];</div><div class="line">  for (int i = 0; i &lt; M; i++)</div><div class="line">  {</div><div class="line">    kernel[i] = new double [N];</div><div class="line">  }</div><div class="line"></div><div class="line">  tmp_arr = new double [M];</div><div class="line"></div><div class="line">  srand(time(0));</div><div class="line">  // 添加一些大数</div><div class="line">  int tmp_id, tmp_size, tmp_val;</div><div class="line">  for (int i = 0; i &lt; M; i++)</div><div class="line">  {</div><div class="line">    tmp_size = random_int(25, 35);</div><div class="line">    for (int j = 0; j &lt; tmp_size; j++)</div><div class="line">    {</div><div class="line">      tmp_id = random_int(0, N);</div><div class="line">      tmp_val = random_double(-10, 10);</div><div class="line"></div><div class="line">      kernel[i][tmp_id] = tmp_val;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  // 生成一组正演解</div><div class="line">  double *fm = new double [N];</div><div class="line">  for (int i = 0; i &lt; N; i++)</div><div class="line">  {</div><div class="line">    fm[i] = random_double(1, 2);</div><div class="line">  }</div><div class="line"></div><div class="line">  // 计算共轭梯度B项</div><div class="line">  double *B = new double [N];</div><div class="line">  for (int i = 0; i &lt; M; i++)</div><div class="line">  {</div><div class="line">    tmp_arr[i] = 0.0;</div><div class="line">    for (int j = 0; j &lt; N; j++)</div><div class="line">    {</div><div class="line">      tmp_arr[i] += kernel[i][j]*fm[j];</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  for (int j = 0; j &lt; N; j++)</div><div class="line">  {</div><div class="line">    B[j] = 0.0;</div><div class="line">    for (int i = 0; i &lt; M; i++)</div><div class="line">    {</div><div class="line">      B[j] += kernel[i][j]*tmp_arr[i];</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  /********************准备工作完成************************/</div><div class="line">  lcg_para self_para = lcg_default_parameters();</div><div class="line">  self_para.max_iterations = 1000;</div><div class="line">  self_para.epsilon = 1e-10;</div><div class="line"></div><div class="line">  // 声明一组解</div><div class="line">  double *m = new double [N];</div><div class="line">  for (int i = 0; i &lt; N; i++)</div><div class="line">    m[i] = 0.0;</div><div class="line"></div><div class="line">  int ret = lcg_solver(CalAx, Prog, m, B, N, &amp;self_para, NULL, LCG_CG);</div><div class="line">  if (ret &lt; 0) std::cerr &lt;&lt; lcg_error_str(ret) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  for (int i = 0; i &lt; N; i++)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; fm[i] &lt;&lt; &quot; &quot; &lt;&lt; m[i] &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  delete[] kernel;</div><div class="line">  delete[] tmp_arr;</div><div class="line">  delete[] fm;</div><div class="line">  delete[] B;</div><div class="line">  delete[] m;</div><div class="line">  return 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
