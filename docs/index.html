<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Liblcg: LCG说明文档</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Liblcg
   &#160;<span id="projectnumber">1.6.0</span>
   </div>
   <div id="projectbrief">C++ Library of Linear Conjugate Gradient Methods</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">LCG说明文档 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> 张壹（zhangyiss@icloud.com）</p>
<p><em>浙江大学地球科学学院·地球物理研究所</em></p>
<h1>简介</h1>
<p>liblcg 是一个独立的、高效的 C++ 线性共轭梯度算法库。包含了实数域的共轭梯度算法、预优共轭梯度算法、共轭梯度平方算法、双稳共轭梯度算法、BB步共轭梯度投影法与SPG共轭梯度投影法。可用于求解如下形式的线性方程组：</p>
<div class="fragment"><div class="line">Ax = B</div>
</div><!-- fragment --><p>其中，A 是一个 N 阶的方阵、x 为 N*1 大小的待求解的模型向量，B 为 N*1 大小的需拟合的目标向量。共轭梯度法广泛应用于无约束与约束的线性最优化问题，拥有优良的收敛与计算效率。其中，共轭梯度法与预优共轭梯度法可用于求解A为对称形式的线性方程组，而共轭梯度平方法与双稳共轭梯度法可用于求解A为非对称形式的线性方程组。同时，两种投影梯度法可用于求解带不等式约束的线性最优化问题。</p>
<h1>安装</h1>
<p>算法库使用 CMake 工具进行汇编，可在不同操作平台生成相应的Makefile或工程文件。</p>
<p>算法库目前有两个可用的编译选项，分别为 LCG_FABS 和 LCG_OPENMP，默认值均为 ON。其中 LCG_FABS 表示是否使用算法库自带的绝对值计算方法。若此值为 OFF 则会使用标准的（cmath）绝对值计算方法。 LCG_OPENMP 为是否使用 OpenMP 对算法进行加速。若此值为 OFF 则表示不使用OpenMP。如需使用OpenMP则需安装相应的依赖库，目前主流操作系统均已内置。</p>
<p>用户可以使用-D命令参数进行条件编译：</p>
<div class="fragment"><div class="line">cmake .. -DLCG_FABS=OFF -DLCG_OPENMP=ON</div>
</div><!-- fragment --><h2>Linux 与 MacOS</h2>
<p>默认的安装路径为 /usr/local。头文件与动态库分别安装于 include 与 lib 文件夹。具体的编译与安装步骤如下：</p>
<ol type="1">
<li>下载安装CMake软件；</li>
<li>下载安装GCC编译器（通常系统已内置）；</li>
<li>在源文件路径内使用如下命令进行编译与安装：</li>
</ol>
<div class="fragment"><div class="line">mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make install</div>
</div><!-- fragment --><h2>Windows</h2>
<h3>MinGW 和 GCC</h3>
<p>Windows系统不包含GNU编译环境，用户需自行下载并配置。方法如下：</p>
<ol type="1">
<li>下载MinGW安装文件，并选择gcc、pthreads与make相关软件包安装；</li>
<li>下载安装CMake软件；</li>
<li>添加CMake与MinGW可执行文件路径至Windows环境变量；</li>
<li>在源文件路径内使用如下命令进行编译与安装：</li>
</ol>
<div class="fragment"><div class="line">mkdir build &amp;&amp; cd build &amp;&amp; cmake .. -G &quot;MinGW Makefiles&quot; &amp;&amp; make install</div>
</div><!-- fragment --><p>默认的安装路径为 D:\Library。头文件与动态库分别安装于 include 与 lib 文件夹。 **注意：**用户需要添加头文件与动态库地址到计算机的环境变量中。</p>
<h3>Visual Studio</h3>
<p>用户可使用CMake工具构建VS工程文件并编译使用动态库。方法如下：</p>
<ol type="1">
<li>下载安装 Visual Studio 软件；</li>
<li>在源文件路径内使用如下命令生成VS工程文件：</li>
</ol>
<div class="fragment"><div class="line">mkdir build &amp;&amp; cd build &amp;&amp; cmake .. -G &quot;Visual Studio 16 2019&quot;</div>
</div><!-- fragment --><p><em>注：如需生成其他版本的VS工程文件，请使用-G命令查看相应的识别码。</em></p>
<ol type="1">
<li>使用 Visual Studio 打开.sln工程文件并编译动态库。</li>
</ol>
<h1>数据类型</h1>
<ol type="1">
<li>浮点类型 <code>lcg_float</code> 。目前只是简单的 <code>double</code> 类型的别名；</li>
<li>枚举类型 <code>lcg_solver_enum</code> 包含了可用的共轭梯度类型。有 <code>LCG_CG</code>，<code>LCG_PCG</code>，<code>LCG_CGS</code>，<code>LCG_BICGSTAB</code>，<code>LCG_BICGSTAB2</code>，<code>LCG_PG</code>和<code>LCG_SPG</code>共7个。分别表示共轭梯度、预优共轭梯度、共轭梯度平方算法、两种双稳共轭梯度算法与两种投影梯度算法；</li>
<li>结构体 <code><a class="el" href="structlcg__para.html" title="Parameters of the conjugate gradient methods.">lcg_para</a></code> 为共轭梯度参数类型。包含 <code>max_iterations</code>，<code>epsilon</code>，<code>abs_diff</code>，<code>restart_epsilon</code> 等变量，包含最大迭代次数、终止精度等条件变量。具体含义请见头文件内的注释。</li>
</ol>
<h1>头文件与函数接口</h1>
<p>使用库函数需在源文件中包含头文件<code><a class="el" href="lcg_8h.html">lcg.h</a></code>，可用的函数接口包括</p>
<ol type="1">
<li><code>lcg_float* <a class="el" href="lcg_8h.html#ad4d1ad1663815eb1214f7683acfd1cbe" title="Locate memory for a lcg_float pointer type.">lcg_malloc(const int n)</a></code> 开辟数组空间；</li>
<li><code>void <a class="el" href="lcg_8h.html#a51d9b69c6afbba37a48470b4e1db4739" title="Destroy memory used by the lcg_float type array.">lcg_free(lcg_float* x)</a></code> 释放数组空间；</li>
<li><code><a class="el" href="structlcg__para.html" title="Parameters of the conjugate gradient methods.">lcg_para</a> <a class="el" href="lcg_8cpp.html#ae709a311e61bd35843a9f4333c38ab18" title="Return a lcg_para type instance with default values.">lcg_default_parameters()</a></code> 返回一组默认的共轭梯度参数；</li>
<li><code>const char* <a class="el" href="lcg_8h.html#a7d76a821bc6ddd804abaf1974e5d7583" title="Return a string explanation for the lcg_solver() function&#39;s return values.">lcg_error_str(int er_index)</a></code> 按照 <code><a class="el" href="lcg_8cpp.html#a5d3eb4595fc2c3d6830c5c5fbe130ae9" title="A combined conjugate gradient solver function.">lcg_solver()</a></code> 函数的返回值显示可能的错误信息。</li>
</ol>
<h2>回调函数</h2>
<h3>正演计算函数接口</h3>
<p>通常我们在使用共轭梯度法求解线性方程组Ax=B时A的维度可能会很大，直接储存A将消耗大量的内存空间，因此一般并不直接计算并储存A而是在需要的时候计算Ax的乘积。因此用户在使用liblcg时需要定义Ax的正演计算函数。该函数的声明必须满足算法库定义的一般形式：</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> void (*<a class="code" href="lcg_8h.html#aad8c7423a269f54e028c07441615fba6">lcg_axfunc_ptr</a>)(<span class="keywordtype">void</span>* instance, <span class="keyword">const</span> <a class="code" href="lcg_8h.html#a5282007dc6f0c317361d25fa0eeb4a35">lcg_float</a>* x, <a class="code" href="lcg_8h.html#a5282007dc6f0c317361d25fa0eeb4a35">lcg_float</a>* prod_Ax, <span class="keyword">const</span> <span class="keywordtype">int</span> n_size);</div>
</div><!-- fragment --><p>函数需定义4个参数，分别为：</p>
<ol type="1">
<li><code>void *instance</code> 传入的实例对象（正演函数为类的成员函数时等于this，否则为空）；</li>
<li><code>const lcg_float *x</code> x数组的指针；</li>
<li><code>lcg_float *prod_Ax</code> Ax乘积数组的指针；</li>
<li><code>const int n_size</code> 矩阵的大小（A的大小为n_size*n_size，x与Ax的大小为n_size*1）。</li>
</ol>
<p>函数的返回值为空。此函数负责计算Ax的乘积，结算结果保存在Ax数组内。此函数在lcg_solver()与clcg_solver()函数内调用并由求解函数负责开辟与销毁Ax数组，用户无需自行操作。</p>
<h3>监控函数接口</h3>
<p>用户可使用下面的函数模版自定义监控函数以显示求解迭代过程，并可以在适当的情况下停止迭代进程。</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> int (*<a class="code" href="lcg_8h.html#af5153afe716c929b922ad48dda46d252">lcg_progress_ptr</a>)(<span class="keywordtype">void</span>* instance, <span class="keyword">const</span> <a class="code" href="lcg_8h.html#a5282007dc6f0c317361d25fa0eeb4a35">lcg_float</a>* m, <span class="keyword">const</span> <a class="code" href="lcg_8h.html#a5282007dc6f0c317361d25fa0eeb4a35">lcg_float</a> converge, <span class="keyword">const</span> <a class="code" href="structlcg__para.html">lcg_para</a>* param, <span class="keyword">const</span> <span class="keywordtype">int</span> n_size, <span class="keyword">const</span> <span class="keywordtype">int</span> k);</div>
</div><!-- fragment --><p>函数模版定义了6个参数，分别为：</p><ol type="1">
<li><code>void* instance</code> 传入的实例对象（监控函数为类的成员函数时等于this，否则为空）；</li>
<li><code>const lcg_float* m</code> 当前迭代的模型参数数组；</li>
<li><code>const lcg_float converge</code> 当前迭代的目标值；</li>
<li><code>const lcg_para* param</code> 当前迭代过程使用的参数；</li>
<li><code>const int n_size</code> 模型数组的大小；</li>
<li><code>const int k</code> 当前迭代的次数。</li>
</ol>
<p>函数的返回值为0时迭代继续，否则迭代终止。此函数参数类型均为常量型，是迭代过程中暴露的变量值。求解过程中每迭代一次即在lcg_solver()与clcg_solver()函数内调用一次。用户可使用需要的变量监控或显示迭代过程。</p>
<h1>求解函数</h1>
<p>用户在定义 正演计算函数与监控函数后即可调用求解函数 <a class="el" href="lcg_8cpp.html#a5d3eb4595fc2c3d6830c5c5fbe130ae9" title="A combined conjugate gradient solver function.">lcg_solver()</a> 或 <a class="el" href="lcg_8cpp.html#a3f5d952c1de72bb77a5f3dfdfe2cb349" title="A combined conjugate gradient solver function with inequality constraints.">clcg_solver()</a> 对线性方程组进行求解，同时提供初始解x与共轭梯度的B项（即拟合的对象）。如果使用预优方法还需要提供预优矩阵P项。目前可用的求解方法如下：</p>
<ol type="1">
<li>LCG_CG：共轭梯度算法；</li>
<li>LCG_PCG：预优共轭梯度算法；</li>
<li>LCG_CGS：共轭梯度平方算法；</li>
<li>LCG_BICGSTAB：双稳共轭梯度算法；</li>
<li>LCG_BICGSTAB2: 双稳共轭梯度算法（带重启功能）；</li>
<li>LCG_PG: BB步投影梯度算法；</li>
<li>LCG_SPG: SPG2投影梯度算法。</li>
</ol>
<p>无约束求解函数的参数形式如下：</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="lcg_8cpp.html#a5d3eb4595fc2c3d6830c5c5fbe130ae9">lcg_solver</a>(<a class="code" href="lcg_8h.html#aad8c7423a269f54e028c07441615fba6">lcg_axfunc_ptr</a> Afp, <a class="code" href="lcg_8h.html#af5153afe716c929b922ad48dda46d252">lcg_progress_ptr</a> Pfp, <a class="code" href="lcg_8h.html#a5282007dc6f0c317361d25fa0eeb4a35">lcg_float</a>* m, <span class="keyword">const</span> <a class="code" href="lcg_8h.html#a5282007dc6f0c317361d25fa0eeb4a35">lcg_float</a>* B, <span class="keyword">const</span> <span class="keywordtype">int</span> n_size, <span class="keyword">const</span> <a class="code" href="structlcg__para.html">lcg_para</a>* param, <span class="keywordtype">void</span>* instance, <a class="code" href="lcg_8h.html#a9ce95cfde91c2580af819d69bdcc86b1">lcg_solver_enum</a> solver_id <span class="keyword">const</span> <a class="code" href="lcg_8h.html#a5282007dc6f0c317361d25fa0eeb4a35">lcg_float</a>* P);</div>
</div><!-- fragment --><p>函数接收9个参数，分别为：</p><ol type="1">
<li><code>lcg_axfunc_ptr Afp</code> 正演计算的回调函数；</li>
<li><code>lcg_progress_ptr Pfp</code> 监控迭代过程的回调函数（非必须，无需监控时使用 NULL 参数即可）；</li>
<li><code>lcg_float* m</code> 模型参数数组，迭代取得的解也保存与此数组；</li>
<li><code>const lcg_float* B</code> Ax = B 中的 B 项；</li>
<li><code>const int n_size</code> 模型参数数组的大小；</li>
<li><code>const lcg_para* param</code> 迭代使用的参数，此参数为 NULL 即使用默认参数；</li>
<li><code>void* instance</code> 传入的实例对象, 此函数在类中使用即为类的 this 指针, 在普通函数中使用时即为 NULL；</li>
<li><code>int solver_id</code> 求解函数使用的求解方法，即上文中 LCG_CG 至 LCG_BICGSTAB2 五种方法，默认的求解方法为 LCG_CGS；</li>
<li><code>const lcg_float* P</code> 预优矩阵，一般是一个N阶的对角阵，这里直接用一个一维数组表示。此参数只在求解方法为 LCG_PCG 时是必须的，其他情况下是一个默认值为 NULL 的参数。</li>
</ol>
<p>投影梯度算法的参数形式如下： </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="lcg_8cpp.html#a3f5d952c1de72bb77a5f3dfdfe2cb349">clcg_solver</a>(<a class="code" href="lcg_8h.html#aad8c7423a269f54e028c07441615fba6">lcg_axfunc_ptr</a> Afp, <a class="code" href="lcg_8h.html#af5153afe716c929b922ad48dda46d252">lcg_progress_ptr</a> Pfp, <a class="code" href="lcg_8h.html#a5282007dc6f0c317361d25fa0eeb4a35">lcg_float</a>* m, <span class="keyword">const</span> <a class="code" href="lcg_8h.html#a5282007dc6f0c317361d25fa0eeb4a35">lcg_float</a>* B, <span class="keyword">const</span> <a class="code" href="lcg_8h.html#a5282007dc6f0c317361d25fa0eeb4a35">lcg_float</a>* low, <span class="keyword">const</span> <a class="code" href="lcg_8h.html#a5282007dc6f0c317361d25fa0eeb4a35">lcg_float</a> *hig, <span class="keyword">const</span> <span class="keywordtype">int</span> n_size, <span class="keyword">const</span> <a class="code" href="structlcg__para.html">lcg_para</a>* param, <span class="keywordtype">void</span>* instance, <a class="code" href="lcg_8h.html#a9ce95cfde91c2580af819d69bdcc86b1">lcg_solver_enum</a> solver_id);</div>
</div><!-- fragment --><p>函数接收10个参数，参数含义与无约束求解函数一致。除了：</p><ol type="1">
<li><code>lcg_float* low</code> 可取的参数范围的底界；</li>
<li><code>lcg_float* hig</code> 可取的参数范围的顶界；</li>
<li><code>int solver_id</code> 求解函数使用的求解方法，可选的类型包括 LCG_PG 与 LCG_SPG。默认类型为 LCG_PG。 </li>
</ol>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="alcg_8cpp_html_a5d3eb4595fc2c3d6830c5c5fbe130ae9"><div class="ttname"><a href="lcg_8cpp.html#a5d3eb4595fc2c3d6830c5c5fbe130ae9">lcg_solver</a></div><div class="ttdeci">int lcg_solver(lcg_axfunc_ptr Afp, lcg_progress_ptr Pfp, lcg_float *m, const lcg_float *B, const int n_size, const lcg_para *param, void *instance, lcg_solver_enum solver_id, const lcg_float *P)</div><div class="ttdoc">A combined conjugate gradient solver function.</div><div class="ttdef"><b>Definition:</b> lcg.cpp:168</div></div>
<div class="ttc" id="astructlcg__para_html"><div class="ttname"><a href="structlcg__para.html">lcg_para</a></div><div class="ttdoc">Parameters of the conjugate gradient methods.</div><div class="ttdef"><b>Definition:</b> lcg.h:83</div></div>
<div class="ttc" id="alcg_8h_html_a9ce95cfde91c2580af819d69bdcc86b1"><div class="ttname"><a href="lcg_8h.html#a9ce95cfde91c2580af819d69bdcc86b1">lcg_solver_enum</a></div><div class="ttdeci">lcg_solver_enum</div><div class="ttdoc">Types of method that could be recognized by the lcg_solver() function.</div><div class="ttdef"><b>Definition:</b> lcg.h:46</div></div>
<div class="ttc" id="alcg_8cpp_html_a3f5d952c1de72bb77a5f3dfdfe2cb349"><div class="ttname"><a href="lcg_8cpp.html#a3f5d952c1de72bb77a5f3dfdfe2cb349">clcg_solver</a></div><div class="ttdeci">int clcg_solver(lcg_axfunc_ptr Afp, lcg_progress_ptr Pfp, lcg_float *m, const lcg_float *B, const lcg_float *low, const lcg_float *hig, const int n_size, const lcg_para *param, void *instance, lcg_solver_enum solver_id)</div><div class="ttdoc">A combined conjugate gradient solver function with inequality constraints.</div><div class="ttdef"><b>Definition:</b> lcg.cpp:226</div></div>
<div class="ttc" id="alcg_8h_html_aad8c7423a269f54e028c07441615fba6"><div class="ttname"><a href="lcg_8h.html#aad8c7423a269f54e028c07441615fba6">lcg_axfunc_ptr</a></div><div class="ttdeci">void(* lcg_axfunc_ptr)(void *instance, const lcg_float *x, lcg_float *prod_Ax, const int n_size)</div><div class="ttdoc">Callback interface for calculating the product of a N*N matrix 'A' multiplied by a vertical vector 'x...</div><div class="ttdef"><b>Definition:</b> lcg.h:148</div></div>
<div class="ttc" id="alcg_8h_html_af5153afe716c929b922ad48dda46d252"><div class="ttname"><a href="lcg_8h.html#af5153afe716c929b922ad48dda46d252">lcg_progress_ptr</a></div><div class="ttdeci">int(* lcg_progress_ptr)(void *instance, const lcg_float *m, const lcg_float converge, const lcg_para *param, const int n_size, const int k)</div><div class="ttdoc">Callback interface for monitoring the progress and terminate the iteration if necessary.</div><div class="ttdef"><b>Definition:</b> lcg.h:165</div></div>
<div class="ttc" id="alcg_8h_html_a5282007dc6f0c317361d25fa0eeb4a35"><div class="ttname"><a href="lcg_8h.html#a5282007dc6f0c317361d25fa0eeb4a35">lcg_float</a></div><div class="ttdeci">double lcg_float</div><div class="ttdoc">A simple definition of the float type we use here. Easy to change in the future. Right now it is just...</div><div class="ttdef"><b>Definition:</b> lcg.h:40</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
